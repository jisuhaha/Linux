2023.12.12
curl Text browser
### Linux Network Setting
nmcli( NetworkMangerComandLineInterface )
- nmcli con show/down/up {interface ID}

> CentOS8 NetworkSeting File

    /etc/sysconfig/network-scripts
    [root@server network-scripts]# ls
    ifcfg-ens160  ifcfg-Wired_connection_1

> CentOS9 NetworkSeting File
 

    /etc/NetworkManager/system-connections
    [root@client system-connections]# ls
    ens160.nmconnection  ens192.nmconnection

### Services
Systemd 
> operating system elements
> - Kernel
> - Application

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQqX310aUqm3YgqtEU0kW4K03GdK-Ot9h7Xvw&usqp=CAU)

Booting Mode Check default.target
> default.target -> /usr/lib/systemd/system/graphical.target (그래픽모드의 부팅모드)

setting bootingMode 
> systemctl set-default {multi-user.target/grphical.target}

Systemd unit

> path : /usr/lib/systemd/system

    [root@server system]# ls
    accounts-daemon.service                     plymouth-poweroff.service
    alsa-restore.service                        plymouth-quit.service
    alsa-state.service                          plymouth-quit-wait.service
    ...

### Systemd를 이용한 서비스 관리
#### 서비스 시작 및 중지 관련 명령어
    systemctl start >> 서비스 시작
    systemctl stop >> 서비스 중지
    systemctl restart >> 서비스 중단 후 재시작
    systemctl reload >> 서비스 중단하지 않고 설정만 다시읽은 후 적용
    systemctl try-restart >> 서비스가 실행중이라면 다시 시작
    systemctl isolate >> service만 실행 나머지 서비스는 모두 중지
    systemctl daemon-reload >> Unit파일을 다시 읽을 때

#### 서비스 활성화 관련 명령어
    systemctl enable >> 부팅시에 서비스가 자동으로 시작되도록 지정
    systemctl reenable >> 링크파일 재생성(disable이후 enable)
    systemctl disable >> 부팅시에 서비스가 자동으로 시작되지 않도록 지정 
    systemctl is-active >> 서비스가 실행중인지 확인
    systemctl is-enable >> 서비스 상태 활성화/비활성화 확인
    systemctl is-failed >> 서비스 시작이 실패했는지 확인
    systemctl mask >> 링크를 /dev/null로 변경
    systemctl unmask >> mask상태 해제를 위해 사용
> mask를 사용하는 경우 장기적으로 서비스를 중지하는 경우 서비스 파일을 변경하지 않고 마스크 처리함

#### Systemd Target 활용
| 런레벨 | Target Unit  |
|--|--|
| <b>0</b> | runlevel10.target, poweroff.target |
| 1 | runlevel11.target, rescue.target |
| 2 | runlevel12.target, multi-user.target |
| <b>3</b> | runlevel13.target, multi-user.target |
| 4 | runlevel14.target, multi-user.target |
| <b>5</b> | runlevel15.target, graphical.target |
| <b>6</b> | runlevel16.target, reboot.target |

    systemctl get-default >> 현재 시스템이 사용중인 기본 Target 확인하기 위해 사용
    systemctl list-units --type target >> 활성화된 모든 Target 보기
    systemctl list-units --type target -all >> 활성화/ 비활성화된 모든 Target 보기
    systemctl set-default { multi-user.target / graphical } >> 현재 사용중인 기본 Target을 변경하기 위해 사용 **재부팅 필요**
    systemctl isolate { multi-user.target / graphical }
    runlevel >> 현재의 Target를 바로 변경하기 위해 사용
    systemctl list-dependencies { multi-user.target / graphical } >> 해당 Target에서 실행되는 모든 서비스 목록을 확인하기 위해 사용

#### ROOT 비밀번호 분실시 찾는 방법
> reboot 이후 e를 통해 edit모드 진입
 ![](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-8-Managing_monitoring_and_updating_the_kernel-ko-KR/images/b76ce21ff4f274aa4b224296cf97f20d/resetting-the-root-password-rd-break.png)
linux 문단 마지막 quiet 뒤에  rd.break -> Ctrl + x
\# mount -o remount,rw /sysroot >> 파일 시스템을 쓰기 가능으로 다시 마운트합니다.
\# chroot /sysroot >> 파일 시스템의 루트 를 변경합니다.
\# passwd >>비밀번호 변경
\# touch / .autorelabel >> 다음 시스템 부팅 시 모든 파일의 레이블을 다시 지정합니다.
\# mount -o remount,ro / >>파일 시스템을 **읽기 전용** 으로 다시 마운트합니다:
\# exit >> chroot 환경을 종료합니다.
\# exit >> 명령을 다시 입력하여 초기화를 다시 시작하고 시스템 부팅을 완료합니다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkzNDY1NzI1NywtMTc4ODA0MDYzNSwtMT
gxNzg4NDYyNCwtMTczNTgwNjQ1Miw4MTg1NzEyNzksMTk2MTYx
NzY3NywtOTI5NTY3MjU3LC05MzgyMzY1MzMsLTE4MDM2MzI5Nz
UsLTI5MTQ5MzgzLDQ4NDU4MjA3NCwxMDkzOTcxMzQ3LC04MDIz
NjQyMDhdfQ==
-->